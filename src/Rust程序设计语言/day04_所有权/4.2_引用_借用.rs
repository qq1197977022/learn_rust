/*
一.引用
    1.运算符
        1.引用: &
        2.解引用: *
    2.本质: 指向引用类型存储在栈中的标头值的指针
    3.引用不持有值所有权 ~ 不曾发生移动
    4.引用和变量异同
        1.同
            1.默认不可变
            2.可用过关键字mut实现可变语义
        2.异
            1.可变引用受限可变 ~ 特定作用域中特定数据只能有一个可变引用 ~ 编译期即避免数据竞争
            2.可变引用和不可变引用不共存

            Note.数据竞争
                1.原因
                    1.>=2个指针同时访问同一数据, 其中>=1个进行写操作
                    2.同步数据访问机制缺失
二.借用
    1.本质: 作为形参的引用
三.悬垂引用
    1.原因: 释放内存时未销毁指针, 导致其指向内存可能已分配给其他持有者
    2.Rust编译器确保引用不会变成悬垂状态: 数据不会在引用离开作用域前离开作用域
*/
fn main() {
//    _fn1_reference(); //引用_借用
    _fn3(); //悬垂引用
}


fn _fn3() {
    let ref_to_nothing = dangling_reference();
}
fn dangling_reference() -> &String {
    let s = String::from("Hello");
    &s
    /*
    1.返回s的引用到调用者
    2.但函数调用结束, s离开作用域, 其值被丢弃, 即对应内存被释放
    3.此时引用&s变为悬垂引用
    */
}


fn _fn1_reference() {
    let s = String::from("Hello");
    calc_len(&s);
    /*
    1.获取String类型数据存储在栈中的标头值的地址 ~ 引用
    2.传递引用到函数calc_len, 与形参s绑定
    */
}
fn calc_len(s: &String) -> usize {
    /*
    1.以String类型引用作为形参 ~ 借用
    */
    s.len()
}

