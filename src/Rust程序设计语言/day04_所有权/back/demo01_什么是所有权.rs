/*
一.内存管理方式
    1.传统方式
        1.自动: GC自动分配/释放内存
        2.手动: 程序员手动分配/释放内存
    2.Rust: 使用所有权系统管理内存
        1.编译器在编译时, 根据所有权系统的一系列规则进行检查
        2.所有权系统不会导致运行时开销
二.堆(Heap)栈(Stack)
    1.像Rust这样的系统编程语言, 了解值是位于栈还是堆上很有必要
    2.堆栈是代码运行时可使用的内存
        A.栈
            1.简介:
                1.FILO
                2.增加数据: 入栈
                3.移出数据: 出栈
            2.特点
                1.快
                    1.只在栈顶存取数据, 无需查找
                    2.栈中数据大小固定
            3.函数调用时传递给函数的值和函数的局部变量被压入栈中, 当函数结束时, 这些值出栈
                1.传递给函数的值
                    1.值
                    2.指针 ~ 地址值
                    3.标头值 ~ 引用
        B.堆
            1.简介
            2.特点
                1.堆上数据在编译时大小未知或可能变化
                2.缺乏组织
                    1.在堆上分配内存 ~ 简称分配
                        1.向操作系统请求指定大小空间
                        2.操作系统在堆上找到一块足够大的空间, 标记为已使用, 并返回该内存空间的地址 ~ 指针
                            1.指针大小固定, 因此可以将指针存储在栈上, 但需要实际数据时必须访问指针
                3.慢
                    1.在堆上分配空间耗时
                    2.必须通过指针访问实际数据 ~ 现代处理器在内存中跳转越少越快 ~ 缓存
        C.综上
            1.只有堆存才有分配/释放的概念, 内存管理即堆存管理
三.所有权功能: MMC
    1.mark: 记录何处的代码在使用堆上的什么数据
    2.min: 最小化堆上冗余数据量
    3.clear: 清理堆上不再使用的数据
    Note: 有了所有权, 无需再考虑堆栈
四.所有权规则
    1.一言蔽之: 所有值有且只有一个所有者, 所有者离开作用域其值即被抛弃
        1.所有者: target ~ 值绑定的目标
五.变量作用域
六.String类型
八.内存分配 ~ 堆内存
    1.字符串字面, 编译时即知其内容, 所以直接被硬编码进最终可执行文件中
        1.快速高效 ~ 源于其不可变性
    2.String类型, 为支持可变, 可增长字符串, 需要在堆上分配编译时未知大小内存
        1.运行时向操作系统请求内存 ~ 所有语言基本一致
            1.由开发人员调用String::from时完成
        2.处理完String时将内存返回给操作系统 ~ 不同语言有所差别
            1.自动: 由GC记录并清除不再使用的内存
            2.手动: 由开发人员确保allocate/free一一对应
                1.忘记回收 ~ 浪费内存
                2.回收过早 ~ 无效变量
                3.重复回收 ~ 二次释放bug ~ 导致内存污染, 可能会导致潜在安全漏洞
            3.Rust所有权系统: 变量离开作用域后其所拥有内存自动释放
                1.当变量离开作用域, Rust在结尾}处, 自动调用drop函数 ~ 可以在该函数中定义释放内存的代码
                2.C++中, 这种item生命周期结束时释放资源的方法称作资源获取即初始化RAII(Resource Acquisition Is Initialization)
                3.RAII对编写Rust代码有深远影响
*/
fn main() {
    /*
    七.软硬编码
        1.硬编码: 不可变
        2.软编码:  运行时可变
    */
    let s = "HelloWorld";
    println!("{}", s);
    /*
    1.字符串字面硬编码进程序
        1.不可变
        2.但并非所有字符串值都是在编写代码时就确定
            eg.用户输入并存储
    2.因此Rust提供了第二种字符串类型String
        1.该类型字符串存储在堆上, 可以存储编译时大小未知的字符串
    */
    let mut s = String::from("HelloWorld");
    s.push_str("World");
    println!("{}", s);
}

//------------------------------------------------------九.变量与数据交互方式------------------------------------------------------
fn main() {
//    mov();
    clone();
}


fn clone() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    /*
        克隆:
          1.依据s1标头值信息, 分配堆内存
          2.依据s1标头值信息, 拷贝堆存数据
          3.与s2绑定标头值, 存储在栈存
    */
    println!("s1 = {}\ts2 = {}", s1, s2);
}
/*fn mov() {
    let x = 5;
    let y = x;
    *//*
        1.拷贝与x绑定, 存放在栈存中的值5, 赋值给y
        2.i32是已知固定大小的值, 因而这两个值均被放入栈存中
    *//*
    println!("x = {}\ty = {}", x, y);


    let s1 = String::from("hello");
    let s2 = s1;
    *//*
        移动
          1.拷贝与s1绑定, 存放在栈存中的标头值, 赋值给s2
          2.使s1无效
    *//*
    println!("{}, world", s2);
    println!("{}, world", s1);
}*/
/*
九.变量与数据交互方式
    1.引用数据类型
      1.移动: 类似浅拷贝 ~ 卸磨杀驴版
      2.克隆: 深拷贝
          1.浅拷贝: 仅拷贝存放在栈存中的标头值, 而不拷贝标头值中指针指向的堆存数据
          2.Rust设计规定, 永不会自动创建数据深拷贝, 因此必须手动完成深拷贝 ~ Rust提供名为clone的通用函数实现深拷贝
    2.栈存数据: 拷贝
        1.值类型: 值拷贝
            1.Copy trait注解 ~ 用于栈存数据类型(数据只存储在栈存)
            2.Rust不允许实现Drop trait类型使用Copy trait
            3.栈存数据及其组合适用Copy trait
                eg. 1.整型
                    2.布尔型
                    3.浮点型
                    4.元素为栈存数据类型的元祖
        2.址类型: 址拷贝 ~ 指针
    3.总结
        1.为什么栈数据类型, Rust采用拷贝的方式, 而引用数据类型采用移动的方式, 即卸磨杀驴版浅拷贝
            1.因为当堆存数据较大时, 开销较大, 可能会对运行时性能造成很大影响, 因而采用移动
*/


//------------------------------------------------------十.所有权与函数------------------------------------------------------
fn main() {
    let s = String::from("hello");
    takes_ownership(s); //移动 s ---> takes_ownership

    let x = 5;
    makes_copy(x);  //浅拷贝
}

fn takes_ownership(str: String) {
    println!("{}", str);
}
fn makes_copy(integer: i32) {
    println!("{}", integer)
}
/*
十.所有权与函数
  1.函数传参与本质即变量赋值, 因而也会移动或复制
*/


//------------------------------------------------------十一.返回值与作用域------------------------------------------------------
fn main() {
    let s1 = gives_ownership(); //移动 gives_ownership ---> s1
    let s2 = String::from("hello");
    let s3 = takes_and_gives_back(s2);
    /*
    移动
        1. s2 ---> takes_and_gives_back
        2. takes_and_gives_back ---> s3
    */

    println!("s1 = {}\ts2 = {}\t", s1, s3)
}

fn gives_ownership() -> String {
    let some_string = String::from("hello哈");
    println!("{}", some_string.len());  //获取字符串字节数
    some_string
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}

/*
十一.返回值与作用域
*/

























